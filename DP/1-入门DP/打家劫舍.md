# [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)
```python
# 反向
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        @cache
        def dfs(i: int) -> int:
            if i < 0:
                return 0
            return max(dfs(i-1), dfs(i-2)+nums[i])
        return dfs(n-1)

# 正向
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        @cache
        def dfs(i: int) -> int:
            if i >= n:
                return 0
            return max(dfs(i+1), dfs(i+2)+nums[i])
        return dfs(0)

```

# [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)
环形
1. 要么抢`[1,n-1]`
2. 要么抢 `[0,n-2]`
```python fold
class Solution:
    def rob0(self, nums: List[int]) -> int:
        n = len(nums)
        @cache
        def dfs(i: int) -> int:
            if i >= n:
                return 0
            return max(dfs(i+1), dfs(i+2)+nums[i])
        return dfs(0)
    
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        return max(self.rob0(nums[:-1]), self.rob0(nums[1:]))
```
# [3186. 施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/)
一个魔法师有许多不同的咒语。

给你一个数组 `power` ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。

已知魔法师使用伤害值为 `power[i]` 的咒语时，他们就 **不能** 使用伤害为 `power[i] - 2` ，`power[i] - 1` ，`power[i] + 1` 或者 `power[i] + 2` 的咒语。

每个咒语最多只能被使用 **一次** 。

请你返回这个魔法师可以达到的伤害值之和的 **最大值** 。


值域上的打家劫舍问题
```python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        cnt=Counter(power)
        a = sorted(cnt) # unique power value
        @cache
        def dfs(i):
            # dfs(i)代表从a[0]到a[i]中进行选择，可以得到的伤害和最大值
            if i<0:
                return 0
            option1 = dfs(i-1) # 不选i
            
            x = a[i] # 选a[i]
            option2 = x * cnt[x]
            j = bisect.bisect_right(a, x-3)
            option2+=dfs(j-1)
            return max(option1, option2)
        return dfs(len(a)-1)
```