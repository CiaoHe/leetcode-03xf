# [688. 骑士在棋盘上的概率](https://leetcode.cn/problems/knight-probability-in-chessboard/)
主要是一个类似MC的思路
```python fold
class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        dirs = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]
        @lru_cache(None)
        def dfs(k, x, y):
            if k == 0:
                return 1
            res = 0
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                if 0 <= nx < n and 0 <= ny < n:
                    res += dfs(k-1, nx, ny)
            return res
        return dfs(k, row, column) / 8**k
```
# [576. 出界的路径数](https://leetcode.cn/problems/out-of-boundary-paths/)
```python fold
class Solution:
    def findPaths(self, m: int, n: int, maxMove: int, startRow: int, startColumn: int) -> int:
        MOD = 10**9 + 7
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        @lru_cache(None)
        def dfs(k, x, y):
	        # 边界条件
            if x < 0 or x >= m or y < 0 or y >= n:
                return 1
            if k == 0:
                return 0
            res = 0
            for dx, dy in dirs:
                nx, ny = x + dx, y + dy
                res += dfs(k-1, nx, ny)
            return res % MOD
        return dfs(maxMove, startRow, startColumn)
```
# [minimax] 用mcmc模拟到角落的概率

一个16x16棋盘上走马，就是说只能横着走2步，竖着走1步，或者竖着走2步横着走1步。假设你的初始位置是左上角(坐标0,0)，请估算从左上角达到任意顶点（包含0,0）要走步数的期望。 
注意点： 1. 棋盘外的点是不合法的。 2. 用蒙特卡罗的思路来做。 3. 向每一个合法的点走的概率是一样的。
```python fold
import random
import numpy as np
def mc_knight_expectation(n:int, trials:int):
    dirs = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]
    moves = []

    for _ in range(trials):
        x, y = 0, 0
        steps = 0

        while True:
            possible_moves = [(x + dx, y + dy) for dx, dy in dirs if 0 <= x + dx < n and 0 <= y + dy < n]
            if not possible_moves:
                break
            nx, ny = random.choice(possible_moves)
            steps += 1
            x, y = nx, ny
            if (x, y) in [(0, 0), (0, n-1), (n-1, 0), (n-1, n-1)]:
                moves.append(steps)
                break

    return np.mean(moves)

print(mc_knight_expectation(15, 50000))
```
# [808. 分汤](https://leetcode.cn/problems/soup-servings/)
你有两种汤，**A** 和 **B**，每种初始为 `n` 毫升。在每一轮中，会随机选择以下四种服务操作中的一种，每种操作的概率为 `0.25`，且与之前的所有轮次 **无关**：

1. 从汤 A 取 100 毫升，从汤 B 取 0 毫升
2. 从汤 A 取 75 毫升，从汤 B 取 25 毫升
3. 从汤 A 取 50 毫升，从汤 B 取 50 毫升
4. 从汤 A 取 25 毫升，从汤 B 取 75 毫升

**注意：**

- 不存在先分配 `100` ml **汤B** 的操作。
- 汤 A 和 B 在每次操作中同时被倒入。
- 如果一次操作要求你倒出比剩余的汤更多的量，请倒出该汤剩余的所有部分。

操作过程在任何回合中任一汤被用完后立即停止。

返回汤 A 在 B 前耗尽的概率，加上两种汤在 **同一回合** 耗尽概率的一半。返回值在正确答案 `10-5` 的范围内将被认为是正确的。

> 用DP的代价就是得提前剪枝
```python
class Solution:
    def soupServings(self, n: int) -> float:
        # 把n变成//25
        n = (n+24)//25
        if n>=179:
            return 1.0

        @cache
        def dfs(i, j):
            # i: a汤剩下的量
            # j: b汤剩下的量
            if i <= 0 and j <= 0:
                return 0.5
            if i <= 0:
                return 1
            if j <= 0:
                return 0
            return 0.25 * (dfs(max(i-4,0), j) + dfs(max(i-3,0), max(j-1,0)) + dfs(max(i-2,0), max(j-2,0)) + dfs(max(i-1,0), max(j-3,0)))
        
        return dfs(n, n)
```