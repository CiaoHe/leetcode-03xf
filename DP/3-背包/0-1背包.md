>[!问题定义]
>0-1背包：有$n$个物品，第$i$个物品的体积是 `w[i]`, 价值是 `v[i]`, 每个物品最多选一次，求体积和不超过 `capacity`时的最大价值和

>[!回溯三问]
>1. 当前操作：枚举第`i` 个物品选还是不选：
>	1. 选：剩余背包容量 -= `w[i]`
>	2. 不选：背包容量不变
>2. 子问题：在剩余容量为`c`时，从前`i`个物品中得到的最大价值和
>3. 转移：
>	1. 不选：`dfs(i-1, c)`
>	2. 选： `dfs(i-1, c-w[i])+v[i]`
>	3. 取舍：`max(dfs(i-1,c), dfs(i-1,c-w[i])+v[i])`

>[!] 常见变形
>1. 至多装`capacity`, 求方案数目 / 最大价值和
>2. 恰好装`capacity`, 求方案数目 / 最大价值和 / 最小价值和
>3. 至少装 `capacity`, 求方案数目 / 最小价值和
# [494. 目标和](https://leetcode.cn/problems/target-sum/)
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        n = len(nums)
        @cache
        def dfs(idx:int, cur:int):
            if idx==n:
                return 1 if cur==target else 0
            return dfs(idx+1, cur+nums[idx]) + dfs(idx+1, cur-nums[idx])
        return dfs(0,0)
```
转化成0-1背包问题
- 假设正数 $p$, 负数 $sum-p$, 那么有$p - (sum-p) = t$, 得到 $p = \frac{t+sum}{2}$
- 问题转化为0-1背包至多有capacity, 求方案数目
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        n = len(nums)
        target += sum(nums)
        if target < 0 or target%2:
            return 0
        target //= 2
        @cache
        def dfs(i,c):
            if i<0:
                return 1 if c==0 else 0
            if c<nums[i]:
                return dfs(i-1,c)
            return dfs(i-1,c) + dfs(i-1,c-nums[i])
        return dfs(n-1,target)
```
# [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)
选还是不选-凑出来一半`sum`
```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        s = sum(nums)
        if s%2:
            return False
        target = s//2
        n = len(nums)
        @lru_cache(None)
        def dfs(i,s):
            if i>=n:
                return s == target
            return dfs(i+1,s+nums[i]) or dfs(i+1,s)
        return dfs(0,0)
```
# [2787. 将一个数字表示成幂的和的方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/)
给你两个 **正** 整数 `n` 和 `x` 。

请你返回将 `n` 表示成一些 **互不相同** 正整数的 `x` 次幂之和的方案数。换句话说，你需要返回互不相同整数 `[n1, n2, ..., nk]` 的集合数目，满足 `n = n1^x + n2^x + ... + nk^x` 。

由于答案可能非常大，请你将它对 `10^9 + 7` 取余后返回。

比方说，`n = 160` 且 `x = 3` ，一个表示 `n` 的方法是 `n = 2^3 + 3^3 + 5^3` 。

```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        # dp[k][j]: 用前j个数的x次幂组成k的方法数
        # k: [0, n]
        # j: [0, max_base]
        max_base = 1
        while pow(max_base, x) <= n:
            max_base += 1
        dp = [[0] * (max_base) for _ in range(n+1)]
        # 边界
        for j in range(max_base):
            dp[0][j] = 1  # 组成0的方法只有1种：什么都不选
        for k in range(1, n+1):
            for j in range(1, max_base):
                dp[k][j] = dp[k][j-1]
                # 判断当前这个最大的j能否被纳入计算
                power = pow(j, x)
                if power <= k:
                    dp[k][j] = (dp[k][j] + dp[k-power][j-1]) % MOD
        return dp[n][max_base-1]
```

如果用0-1背包模版的话
```python
class Solution:
    def numberOfWays(self, n: int, x: int) -> int:
        MOD = 10**9 + 7
        f = [1] + [0] * n
        for i in range(1, n+1):
            v = i**x
            if v > n:
                break
            for j in range(n, v-1, -1):
                f[j] = (f[j] + f[j-v]) % MOD
        return f[n]
```

# [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)
给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

> 可以认为是双循环的0/1背包问题

```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0] * (n+1) for _ in range(m+1)] # dp[i][j] 表示使用i个0和j个1能组成的最大字符串数
        for s in strs:
            cnt0 = s.count('0')
            cnt1 = s.count('1')
            # 背包问题，从后往前遍历，因为每个字符串只能用一次
            for i in range(m, cnt0-1, -1): 
                for j in range(n, cnt1-1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-cnt0][j-cnt1] + 1)
        return dp[m][n]
```