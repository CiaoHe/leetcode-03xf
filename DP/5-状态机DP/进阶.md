# [2272. 最大波动的子字符串](https://leetcode.cn/problems/substring-with-largest-variance/)
字符串的 **波动** 定义为子字符串中出现次数 **最多** 的字符次数与出现次数 **最少** 的字符次数之差。
给你一个字符串 `s` ，它只包含小写英文字母。请你返回 `s` 里所有 **子字符串的** **最大波动** 值。
**子字符串** 是一个字符串的一段连续字符序列。

- 枚举两个字符可能的组合 a and b
- 如果出现a, 结果+1, 出现b, 结果-1, 其他不计入
- `f[i][0]` 以s[i]结尾连续 出现a的个数
- `f[i][1]`以s[i]结尾连续 并且包含a和b的子串的波动值

**为什么需要 `max(f1, f0)`？**
当遇到字符 `b` 时，我们需要更新 `f1`，因为 `b` 的出现会减少波动值。此时有两种情况需要考虑：
- ​**情况 1**：`f1` 是当前子字符串的波动值，它已经包含了之前的 `a` 和 `b` 的出现次数。
- ​**情况 2**：`f0` 是当前字符之前连续出现 `a` 的个数，它表示一个新的子字符串的起点。也就是说新的子字符串可以包括前面那些`a`以及现在遇到的这个`b`
通过 `max(f1, f0)`，我们选择这两种情况中较大的值作为新的波动值的基础。这是因为：
- 如果 `f1` 更大，说明当前子字符串的波动值已经包含了更多的 `a`，我们需要在此基础上减去 `b` 的出现次数。
- 如果 `f0` 更大，说明从当前字符开始，连续出现 `a` 的个数更多，我们需要以这个新的子字符串为基础计算波动值。
```python
class Solution:
    def largestVariance(self, s: str) -> int:
        ans = 0
        for a,b in permutations(ascii_lowercase, 2):
            if a==b:
                continue
            f0 = 0 # 以当前字符为结尾 连续出现a的个数
            f1 = -float('inf') # 以当前字符为结尾 并且包含a和b的子串的波动值
            for ch in s:
                if ch == a: # 当前字符是a(最大次数char)
                    f0 += 1
                    f1 += 1
                elif ch == b: # 当前字符是b(最小次数char)
                    f1 = max(f1, f0)-1 # 波动值
                    f0 = 0
                ans = max(ans, f1)
        return ans
```