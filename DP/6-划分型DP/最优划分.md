è®¡ç®—æœ€å°‘ï¼ˆæœ€å¤šï¼‰å¯ä»¥åˆ’åˆ†å‡ºå¤šå°‘æ®µã€æœ€ä¼˜åˆ’åˆ†å¾—åˆ†ç­‰ã€‚
ä¸€èˆ¬å®šä¹‰ `ğ‘“[ğ‘–]` è¡¨ç¤ºé•¿ä¸º ğ‘– çš„å‰ç¼€ `ğ‘[:ğ‘–]`åœ¨é¢˜ç›®çº¦æŸä¸‹ï¼Œåˆ†å‰²å‡ºçš„æœ€å°‘ï¼ˆæœ€å¤šï¼‰å­æ•°ç»„ä¸ªæ•°ï¼ˆæˆ–è€…å®šä¹‰æˆåˆ†å‰²æ–¹æ¡ˆæ•°ï¼‰
æ–¹æ¡ˆï¼šæšä¸¾æœ€åä¸€ä¸ªå­æ•°ç»„çš„å·¦ç«¯ç‚¹L, ä»`f[L]` è½¬ç§»åˆ° `f[i]`, å¹¶ä¸”è€ƒè™‘`a[L:i]`å¯¹æœ€ä¼˜è§£çš„å½±å“

#  [132. åˆ†å‰²å›æ–‡ä¸² II](https://leetcode.cn/problems/palindrome-partitioning-ii/)
```python
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        def is_palindrome(s):
            return s == s[::-1]

        dp = [n] * n 
        # dp[i] è¡¨ç¤ºå‰iä¸ªå­—ç¬¦çš„æœ€å°åˆ†å‰²æ¬¡æ•°

        for i in range(n):
            if is_palindrome(s[:i+1]):
                dp[i] = 0
                continue

            for j in range(i):
                if is_palindrome(s[j+1:i+1]):
                    dp[i] = min(dp[i], dp[j] + 1)
        return dp[-1]
```
å¦‚æœæ”¹ç”¨è®°å¿†åŒ–æœç´¢ (è¶…æ—¶)
```python
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        @lru_cache
        def is_palindrome(l, r): # inclusive
            if l >= r:
                return True
            return s[l] == s[r] and is_palindrome(l+1, r-1) 

        @lru_cache
        def dfs(i):
            if is_palindrome(0, i):
                return 0
            res = float('inf')
            for j in range(1, i+1):
                if is_palindrome(j, i):
                    res = min(res, dfs(j-1)+1)
            return res

        return dfs(n-1)
```