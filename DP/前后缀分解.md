# [2163. 删除元素后和的最小差值](https://leetcode.cn/problems/minimum-difference-in-sums-after-removal-of-elements/)
给你一个下标从 **0** 开始的整数数组 `nums` ，它包含 `3 * n` 个元素。

你可以从 `nums` 中删除 **恰好** `n` 个元素，剩下的 `2 * n` 个元素将会被分成两个 **相同大小** 的部分。

- 前面 `n` 个元素属于第一部分，它们的和记为 `sumfirst` 。
- 后面 `n` 个元素属于第二部分，它们的和记为 `sumsecond` 。

两部分和的 **差值** 记为 `sumfirst - sumsecond` 。

- 比方说，`sumfirst = 3` 且 `sumsecond = 2` ，它们的差值为 `1` 。
- 再比方，`sumfirst = 2` 且 `sumsecond = 3` ，它们的差值为 `-1` 。

请你返回删除 `n` 个元素之后，剩下两部分和的 **差值的最小值** 是多少。


```python
class Solution:
    def minimumDifference(self, nums: List[int]) -> int:
        import heapq

        n = len(nums) // 3

        # Maintain a max heap for the left part to always keep the n smallest elements' sum
        # 最大堆
        left_heap = [-x for x in nums[:n]] # python 默认是最小堆，所以需要取负号
        heapq.heapify(left_heap)
        left_sum = sum(nums[:n])
        left_sums = [left_sum]

        for i in range(n, 2 * n):
            heapq.heappush(left_heap, -nums[i])
            left_sum += nums[i] + heapq.heappop(left_heap)
            left_sums.append(left_sum)

        # Maintain a min heap for the right part to always keep the n largest elements' sum
        right_heap = nums[2 * n:]
        heapq.heapify(right_heap)
        right_sum = sum(nums[2 * n:])
        right_sums = [right_sum]

        for i in range(2 * n - 1, n - 1, -1):
            heapq.heappush(right_heap, nums[i])
            right_sum += nums[i] - heapq.heappop(right_heap)
            right_sums.append(right_sum)

        right_sums = right_sums[::-1]

        # 遍历每一个可能的分割点，计算左右两部分的差值
        res = float('inf')
        for i in range(n + 1):
            res = min(res, left_sums[i] - right_sums[i])

        return res
```