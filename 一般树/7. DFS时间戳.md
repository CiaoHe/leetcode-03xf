可以把树上问题转化成数组问题，比如子树的操作转化成子数组的操作。通常要结合其他数据结构。

# [2322. 从树中删除边的最小分数](https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/)
存在一棵无向连通树，树中有编号从 `0` 到 `n - 1` 的 `n` 个节点， 以及 `n - 1` 条边。

给你一个下标从 **0** 开始的整数数组 `nums` ，长度为 `n` ，其中 `nums[i]` 表示第 `i` 个节点的值。另给你一个二维整数数组 `edges` ，长度为 `n - 1` ，其中 `edges[i] = [ai, bi]` 表示树中存在一条位于节点 `ai` 和 `bi` 之间的边。

删除树中两条 **不同** 的边以形成三个连通组件。对于一种删除边方案，定义如下步骤以计算其分数：

1. 分别获取三个组件 **每个** 组件中所有节点值的异或值。
2. **最大** 异或值和 **最小** 异或值的 **差值** 就是这一种删除边方案的分数。

- 例如，三个组件的节点值分别是：`[4,5,7]`、`[1,9]` 和 `[3,3,3]` 。三个异或值分别是 `4 ^ 5 ^ 7 = _**6**_`、`1 ^ 9 = _**8**_` 和 `3 ^ 3 ^ 3 = _**3**_` 。最大异或值是 `8` ，最小异或值是 `3` ，分数是 `8 - 3 = 5` 。

返回在给定树上执行任意删除边方案可能的 **最小** 分数。

```python
class Solution:
    def minimumScore(self, nums: List[int], edges: List[List[int]]) -> int:
        n = len(nums)
        adj = [[] for _ in range(n)]
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        
        # 我们枚举任何两条边，断开，然后计算剩下的三个cluster的异或值，计算最大和最小的计算
        # 假设xor[i] 代表i的子树的异或和
        # 枚举我们要删除的两条边x1-y1, x2-y2 (这里x1是y1的父亲， x2是y2的父亲)。删除按照三种方式讨论
        # 1. 如果删除的两条边在同一个子树内部，且[0-x1] [-y1-x2] [-y2-], 那么三个联通cluster的值是（从下到上): xor[y2], xor[y1]^xor[y2], xor[0]^xor[y1]
        # 2. 类似1，但是[0-x2] [-y2-x1] [-y1-], 那么三个联通cluster的值是（从下到上): xor[y1], xor[y2]^xor[y1], xor[0]^xor[y2]
        # 3. 删除的两条边在两个子树，那么可以表示为 xor[y1], xor[y2], xor[0]^xor[y1]^xor[y2]

        # 下一步的重点是需要搞清楚我们遍历的两条边x1-y1, x2-y2到底在什么位置 （是1/2/3？）
        # solution: 用dfs打时间戳，然后根据时间戳判断
        # 1. 如果x是y的祖先，那么有 in[x] < in[y] <= out[y] <= out[x], 简化为in[x] < in[y] <= out[x]

        xor = [0] * n
        _in = [0] * n
        _out = [0] * n
        parent = [-1] * n
        time = 0

        def dfs(x:int, fa:int) -> None:
            nonlocal time
            _in[x] = time
            time += 1
            xor[x] = nums[x]
            for y in adj[x]:
                if y == fa:
                    continue
                parent[y] = x
                dfs(y, x)
                xor[x] ^= xor[y]
            _out[x] = time - 1

        dfs(0, -1)

        def is_ancestor(x:int, y:int) -> bool:
            return _in[x] <= _in[y] <= _out[x]

        res = float('inf')
        for i, (x1, y1) in enumerate(edges):
            if parent[y1] != x1:
                x1, y1 = y1, x1
            for j in range(i + 1, len(edges)):
                x2, y2 = edges[j]
                if parent[y2] != x2:
                    x2, y2 = y2, x2

                if is_ancestor(y1, y2):
                    a, b, c = xor[y2], xor[y1] ^ xor[y2], xor[0] ^ xor[y1]
                elif is_ancestor(y2, y1):
                    a, b, c = xor[y1], xor[y2] ^ xor[y1], xor[0] ^ xor[y2]
                else:
                    a, b, c = xor[y1], xor[y2], xor[0] ^ xor[y1] ^ xor[y2]
                res = min(res, max(a, b, c) - min(a, b, c))
        return res
```