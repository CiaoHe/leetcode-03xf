# [162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)
```python fold
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        nums = [-float('inf')] + nums + [-float('inf')]
        n = len(nums)
        l, r = 1, n-2
        while l <= r:
            mid = (l + r) // 2
            # if is peak
            if nums[mid-1] < nums[mid] > nums[mid+1]:
                return mid - 1
            elif nums[mid-1] < nums[mid]:
                l = mid + 1 # actually is mid
            else:
                r = mid - 1 # actually is mid
        return l
```
# [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)
思考：
1. 二分查找，但是需要考虑旋转
	1. 旋转后，数组被分成两部分，两部分都是有序的
	2. 可以先找到旋转点，然后分别在两部分进行二分查找 [[#[153. 寻找旋转排序数组中的最小值](https //leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)]]
2. 如何寻找到旋转点？
	- 二分查找：找到旋转点 (最小的元素)
3. 找到旋转点之后如何找到target?
	- 根据旋转点分割为两部分，确定在哪一部分寻找
```python fold
class Solution:
    def search(self, nums: List[int], target: int) -> int:
	    n = len(nums)
        l, r = 0, n-1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] > nums[r]:
                # 旋转点在 mid 右边
                l = mid + 1
            else:
                # 旋转点在 mid 或者 mid 左边
                r = mid
                
        # l 是旋转点, 那么原数组被分为两部分：
        # 0 ~ l-1 和 l ~ n-1
        # 如果 target 在 0 ~ l-1 之间，那么在 0 ~ l-1 中进行二分查找：如何判断在哪个部分？如果 target >= nums[rotate_point]，则在 0 ~ l-1 中，否则在 l ~ n-1 中
        # 如果 target 在 l ~ n-1 之间，那么在 l ~ n-1 中进行二分查找
        # 否则返回 -1
        rotate_point = l

        if target >= nums[rotate_point] and target <= nums[n-1]:
            l, r = rotate_point, n-1
        else:
            l, r = 0, rotate_point-1

        # 常规的二分查找
        while l <= r:
            mid = (l + r) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        return -1
```
# [153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)
```python fold
class Solution:
    def findMin(self, nums: List[int]) -> int:
        n = len(nums)
        l, r = 0, n-1
        while l < r:
            mid = (l + r) // 2
            if nums[mid] < nums[r]:
                r = mid # 最小值/旋转点 在 mid 左边 或者 mid 本身
            else:
                l = mid + 1 # 最小值/旋转点 在 mid 右边
        return nums[l]
```
# [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)
O(m+n) 合并链表：找到第(m+n)//2个数
```python fold
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        p1, p2 = 0, 0
        m1, m2 = 0, 0
        total = m + n
        for _ in range(total // 2 + 1):
            m2 = m1
            if p1 < m and p2 < n:
                if nums1[p1] < nums2[p2]:
                    m1 = nums1[p1]
                    p1 += 1
                else:
                    m1 = nums2[p2]
                    p2 += 1
            elif p1 < m:
                m1 = nums1[p1]
                p1 += 1
            else:
                m1 = nums2[p2]
                p2 += 1
        return m1 if total % 2 == 1 else (m1 + m2) / 2
```
O(log(m+n))
```python fold
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        # 假定nums1的长度小于nums2的长度， 这样保证中位数要么都在nums2中，要么就是nums1和nums2的交界处
        if m > n:
            nums1, nums2, m, n = nums2, nums1, n, m
        
        l = 0 # 二分查找的左边界, 设在nums1中
        r = m # 二分查找的右边界, 设在nums1中
        while l <= r:
            partition1 = (l + r) // 2 # 在nums1中分割的位置
            partition2 = (m + n + 1) // 2 - partition1 # 在nums2中分割的位置, 这样保证nums1和nums2的分割位置的和为(m + n + 1) // 2

            # 如此，nums1和nums2分割成以下四个部分
            # nums1_left = nums1[0: partition1]
            # nums1_right = nums1[partition1:]
            # nums2_left = nums2[0: partition2]
            # nums2_right = nums2[partition2:]
            nums1_left_max = float('-inf') if partition1 == 0 else nums1[partition1 - 1]
            nums1_right_min = float('inf') if partition1 == m else nums1[partition1]
            nums2_left_max = float('-inf') if partition2 == 0 else nums2[partition2 - 1]
            nums2_right_min = float('inf') if partition2 == n else nums2[partition2]

            # 如果nums1_left_max <= nums2_right_min and nums2_left_max <= nums1_right_min, 则找到了中位数
            if nums1_left_max <= nums2_right_min and nums2_left_max <= nums1_right_min:
                if (m + n) % 2 == 1:
                    return max(nums1_left_max, nums2_left_max)
                else:
                    return (max(nums1_left_max, nums2_left_max) + min(nums1_right_min, nums2_right_min)) / 2
            elif nums1_left_max > nums2_right_min:
                r = partition1 - 1
            else:
                l = partition1 + 1
```