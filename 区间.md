# [57. 插入区间](https://leetcode.cn/problems/insert-interval/)
1. 可以无脑append newInterval然后用56 完成merge
2. O(n)做法：分类讨论+用栈
```python fold
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:        
        na, nb = newInterval
        if not intervals:
            return [[na, nb]]
        if na > intervals[-1][1]:
            return intervals + [[na, nb]]
        if nb < intervals[0][0]:
            return [[na, nb]] + intervals
        
        res = [] # as a stack
        inserted = False
        for a,b in intervals:
            if res[-1][1] < na:
                res.append([a,b])
            # if [na,nb] is left of [a,b]
            elif nb < a:
                if not inserted:
                    res.append([na, nb])
                    inserted = True
                res.append([a,b])
            # if overlap
            else:
                # flatten the na, nb
                na = min(na, a)
                nb = max(nb, b)
        if not inserted:
            res.append([na, nb])
        return res

```
# [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
经典吹箭
按照需求刷新箭矢的伤害范围
```python fold
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: x[1])
        arrows = 1
        _, b = points[0]
        for start, end in points[1:]:
            if start > b:
                arrows += 1
                b = end
        return arrows
```