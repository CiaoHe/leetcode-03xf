# [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)
类似接雨水，维护left right两个数组
```python
class Solution:
    def largestRectangleArea(self, heights: List[int]) -> int:
        n = len(heights)
        left = [0] * n # 左边第一个小于heights[i]的下标
        right = [0] * n # 右边第一个小于heights[i]的下标
        st = [] # 单调栈
        for i,x in enumerate(heights):
            while st and heights[st[-1]] >= x:
                st.pop()
            left[i] = st[-1] if st else -1
            st.append(i)
        st = []
        for i in range(n-1, -1, -1):
            while st and heights[st[-1]] >= heights[i]:
                st.pop()
            right[i] = st[-1] if st else n
            st.append(i)
        return max((right[i]-left[i]-1)*heights[i] for i in range(n))
```

# [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)
问题化简：
逐行遍历矩阵，将每一行视为一个直方图的底部，并计算当前行的直方图高度，然后利用 `largestRectangleArea` 函数[[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)](#[84.%20柱状图中最大的矩形](https%20//leetcode.cn/problems/largest-rectangle-in-histogram/))来计算当前直方图中的最大矩形面积。
1. **将矩阵转换为直方图**：
    - 对于每一行，计算从该行开始向上的连续 `'1'` 的数量，形成一个直方图。
    - 例如，对于矩阵：
        ["1","0","1","0","0"],
        ["1","0","1","1","1"],
        ["1","1","1","1","1"],
        ["1","0","0","1","0"]
        第一行的直方图是 `[1, 0, 1, 0, 0]`，第二行的直方图是 `[2, 0, 2, 1, 1]`，第三行的直方图是 `[3, 1, 3, 2, 2]`，第四行的直方图是 `[4, 0, 0, 3, 0]`。
2. **计算每个直方图的最大矩形面积**：
    - 对于每个直方图，使用 `largestRectangleArea` 函数计算最大矩形面积。
    - 这个函数通过维护一个单调栈来找到每个柱子的左右边界，从而计算最大面积。
3. **取所有直方图的最大矩形面积中的最大值**：
    - 最终的结果是所有直方图最大矩形面积中的最大值。
```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        m, n = len(matrix), len(matrix[0])
        if m == 0 or n == 0: return 0

        def largestRectangleArea(heights: List[int]) -> int:
            n = len(heights)
            left = [0] * n
            right = [0] * n
            st = []
            for i,x in enumerate(heights):
                while st and heights[st[-1]] >= x:
                    st.pop()
                left[i] = st[-1] if st else -1
                st.append(i)
            st = []
            for i in range(n-1, -1, -1):
                while st and heights[st[-1]] >= heights[i]:
                    st.pop()
                right[i] = st[-1] if st else n
                st.append(i)
            return max((right[i]-left[i]-1)*heights[i] for i in range(n))
        
        heights = [0] * n
        res = 0
        for i in range(m):
            for j in range(n):
                heights[j] = 0 if matrix[i][j] == '0' else heights[j] + 1
            res = max(res, largestRectangleArea(heights))
        return res
```
# [1504. 统计全 1 子矩形](https://leetcode.cn/problems/count-submatrices-with-all-ones/)
给你一个 `m x n` 的二进制矩阵 `mat` ，请你返回有多少个 **子矩形** 的元素全部都是 1 。

官方解答
```python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0
        dp = [[0] * n for _ in range(m)] # 当前以(i,j)为右下角，向左延伸连续1的个数
        for i in range(m):
            for j in range(n):
                if j == 0:
                    dp[i][j] = mat[i][j]
                else:
                    # 试图向左扩展
                    dp[i][j] = dp[i][j-1] + 1 if mat[i][j] else 0

                cur = dp[i][j] # 矩形的底最大值
                # 从i往上进行scan
                for k in range(i, -1, -1):
                    # 木桶原理，当前行只能支持cur个矩形的加入
                    cur = min(cur, dp[k][j])
                    if cur == 0:
                        break
                    ans += cur
        return ans
```

方法一：全 h 子数组的数目
枚举子矩形的上下边界，统计每一列的 1 的个数，把原问题「压缩」为一维数组上的问题。
![example](https://pic.leetcode.cn/1750468652-DSwIKo-lc1504.jpg)
在示例 2 中，假设现在枚举到子矩形的上边界为 0 行，下边界为 1 行，即 mat 的前两行。子矩形的高 h=2。

统计每一列的 1 的个数，得到一个一维数组 a=[0,2,2,1]。我们要找的子矩形，就是 a 的子数组。由于全 1 子矩形的每一列都是 1，所以子数组的每一项都得是子矩形的高 h=2。问题变成：统计 a 的全 h 子数组的数目。
做法同 2348. 全 0 子数组的数目。
代码实现时，外层循环枚举上边界，内层循环枚举下边界。当下边界 bottom 加一时，只需把每个 a[j] 都增加相应的 mat\[bottom\]\[j\]，无需整个重新统计。
```python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0
        for top in range(m):
            # 每一列1的个数 -> a
            a = [0] * n 
            for bottom in range(top, m):
                height = bottom - top + 1
                last = -1 # 最近一列不满足全1条件的位置​​
                for j in range(n):
                    a[j] += mat[bottom][j]
                    if a[j] != height:
                        last = j
                    else:
                        ans += j - last
        return ans
```

> 单调stack

在示例 2 中，当我们枚举到最后一行时，柱子高度为 heights=[1,3,3,0]。然后枚举子矩形的右边界：
- 右边界为 j=0，子矩形只有 1 个。
- 右边界为 j=1，子矩形分成两类：
	- 左边界 <1。在右边界为 j=0 时我们算出这有 1 个，现在将其右边界扩展到 j=1，得到 1 个新的子矩形。
	- 左边界 ≥1。左边界只能是 1，矩形高度有 1,2,3 共 3 种，有 1×3=3 个子矩形。
- 右边界为 j=2，子矩形分成两类：
	- 左边界 <1。在右边界为 j=0 时我们算出这有 1 个，现在将其右边界扩展到 j=2，得到 1 个新的子矩形。
	- 左边界 ≥1。左边界可以是 1,2 共 2 种，矩形高度有 1,2,3 共 3 种，有 2×3=6 个子矩形。
- 右边界为 j=3，高度为 0，没有子矩形。

一般地，用 单调栈 计算小于 heights[j] 的左边最近柱子的位置 left，把子矩形分成两类：

- 左边界 ≤left。假设在右边界为 j=left 时我们算出这有 f 个，现在将其右边界扩展到 j，得到 f 个新的子矩形。
- 左边界 >left。矩形左边界可以是 left+1,left+2,…,j，共 j−left 种；矩形高度可以是 1,2,…,heights[j]，共 heights[j] 种。所以有 (j−left)⋅heights[j] 个子矩形。
- 二者相加，就是右边界在 j 的子矩形个数。加到答案中。

```python
class Solution:
    def numSubmat(self, mat: List[List[int]]) -> int:
        m, n = len(mat), len(mat[0])
        ans = 0
        heights = [0] * n
        for i,row in enumerate(mat):
            for j,x in enumerate(row):
                if x:
                    heights[j] += 1
                else:
                    heights[j] = 0

            # (j, f, heights[j])
            # j: 当前的右边界
            st = [(-1, 0, -1)]
            for j,h in enumerate(heights):
                while st[-1][2] >= h:
                    st.pop()
                # 找到小于heights[j]的最左边的柱子
                left, f, _ = st[-1]

                # 计算底边为row， 右边界为j的矩形个数
                # 1. 左边界<=left, 每个矩形的右边界都可以拓展到j, 一共f个
                # 2. 左边界>left, 左边界有(j-left)个，高度有h种，一共(j-left)*h个
                f += (j-left)*h
                ans += f
                st.append((j, f, h))
        return ans
```