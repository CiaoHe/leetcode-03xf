# [3542. 将所有元素变为 0 的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/)
给你一个大小为 `n` 的 **非负** 整数数组 `nums` 。你的任务是对该数组执行若干次（可能为 0 次）操作，使得 **所有** 元素都变为 0。

在一次操作中，你可以选择一个子数组 `[i, j]`（其中 `0 <= i <= j < n`），将该子数组中所有 **最小的非负整数** 的设为 0。

返回使整个数组变为 0 所需的**最少**操作次数。

一个 **子数组** 是数组中的一段连续元素。


根据题意，我们应该把数字中最小的数先变成 0，再把次小的数变成 0，依此类推。在这里过程中，如果两个数之间有更小的数隔开，那么它们需要额外的一次操作才能变成 0。

nums=[1,2,1,2,1,2]
- 第一步去掉所有最小的1，变成[0,2,0,2,0,2]
- 后面我们需要对被分割开的每一个段进行操作

我们可以维护一个从栈底到栈顶单调递增的栈 stk，遍历数组 nums 中的每个数 x：

- 当栈顶元素大于 x 时，说明 x 将栈顶元素隔开了，我们需要把栈顶元素弹出，并将答案加 1，直到栈顶元素不大于 x 为止。
	- [1,2,1] 的时候发现栈顶元素2大于当前元素1，那么我们就需要把2给pop出来，同时ans+=1（因为我们后面要单独对这个2进行处理)
	- 接下来因为当前元素1和栈剩下的元素1一样，所以不必要再入栈
- 如果 x 不为 0，且栈为空或者栈顶元素不等于 x，则将 x 入栈。
遍历结束后，栈中剩余的元素都需要额外的一次操作才能变成 0，因此我们将答案加上栈的大小即可。

```python
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        ans = 0
        st = []
        for x in nums:
            while st and st[-1] > x:
                st.pop()
                ans += 1
            if x>0 and (not st or st[-1]<x):
                st.append(x)
        return ans + len(st)
```