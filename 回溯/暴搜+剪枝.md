#  [79. 单词搜索](https://leetcode.cn/problems/word-search/)
- 可以用染色法代替回溯
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        m, n = len(board), len(board[0])
        # find the first character of word in board

        def dfs(board, word, i, j, k):
            if k == len(word):
                return True
            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k] or board[i][j] == '#':
                return False
            tmp, board[i][j] = board[i][j], '#'
            res = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1)
            board[i][j] = tmp
            return res

        for i in range(m):
            for j in range(n):
                if board[i][j] == word[0]:
                    if dfs(board, word, i, j, 0):
                        return True
        return False

# 回溯dfs
visited = set()
def dfs(board, word, i, j, k):
	if k == len(word):
		return True
	if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[k] or (i, j) in visited:
		return False
	visited.add((i, j))
	res = dfs(board, word, i+1, j, k+1) or dfs(board, word, i-1, j, k+1) or dfs(board, word, i, j+1, k+1) or dfs(board, word, i, j-1, k+1)
	visited.remove((i, j))
	return res
```

# [2056. 棋盘上有效移动组合的数目](https://leetcode.cn/problems/number-of-valid-move-combinations-on-chessboard/)
```python
class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        n = len(pieces)
        rook_dir = [(0,1), (1,0), (0,-1), (-1,0)]
        bishop_dir = [(1,1), (1,-1), (-1,1), (-1,-1)]
        queen_dir = rook_dir + bishop_dir
        dir_map = {'rook': rook_dir, 'bishop': bishop_dir, 'queen': queen_dir}

        # 可以先预处理每个piece的移动范围
        def get_range(piece: str, position: List[int]) -> List[Tuple[int, int]]:
            x0,y0 = position
            res = [(x0,y0,0,0,0)] # 原地不动
            for dx, dy in dir_map[piece]:
                step = 1
                x,y = x0+dx,y0+dy
                while 0 < x <= 8 and 0 < y <= 8:
                    res.append((x0,y0,dx,dy,step))
                    step += 1
                    x += dx
                    y += dy
            return res
        ranges = [get_range(piece, position) for piece, position in zip(pieces, positions)]

        def check(move1: Tuple[int, int, int, int, int], move2: Tuple[int, int, int, int, int]) -> bool:
            # 检查move1和move2是否冲突
            x1,y1,dx1,dy1,step1 = move1
            x2,y2,dx2,dy2,step2 = move2
            for i in range(max(step1, step2)):
                if i<step1:
                    x1 += dx1
                    y1 += dy1
                if i<step2:
                    x2 += dx2
                    y2 += dy2
                if (x1,y1) == (x2,y2):
                    return False
            return True

        # 使用dfs枚举所有可能的移动方案
        
        ans = 0
        paths = [None]*n # 每个piece的移动路径

        def dfs(i: int) -> None:
            # i: 当前piece
            # 枚举所有可能的移动方案
            if i == n:
                nonlocal ans
                ans += 1
                return
            for move in ranges[i]:
                if any(not check(move, paths[j]) for j in range(i)):
                    continue
                paths[i] = move
                dfs(i+1)
                paths[i] = None
        
        dfs(0)
        return ans
```

# [679. 24 点游戏](https://leetcode.cn/problems/24-game/)
给定一个长度为4的整数数组 `cards` 。你有 `4` 张卡片，每张卡片上都包含一个范围在 `[1,9]` 的数字。您应该使用运算符 `['+', '-', '*', '/']` 和括号 `'('` 和 `')'` 将这些卡片上的数字排列成数学表达式，以获得值24。

你须遵守以下规则:

- 除法运算符 `'/'` 表示实数除法，而不是整数除法。
    - 例如， `4 /(1 - 2 / 3)= 4 /(1 / 3)= 12` 。
- 每个运算都在两个数字之间。特别是，不能使用 `“-”` 作为一元运算符。
    - 例如，如果 `cards =[1,1,1,1]` ，则表达式 `“-1 -1 -1 -1”` 是 **不允许** 的。
- 你不能把数字串在一起
    - 例如，如果 `cards =[1,2,1,2]` ，则表达式 `“12 + 12”` 无效。

如果可以得到这样的表达式，其计算结果为 `24` ，则返回 `true` ，否则返回 `false` 。


```python
class Solution:
    def judgePoint24(self, cards: List[int]) -> bool:
        def operate(a, b, op):
            if op == '+':
                return a + b
            elif op == '-':
                return a - b
            elif op == '*':
                return a * b
            elif op == '/':
                return a / b

        def dfs(cards: List[int]) -> bool:
            if len(cards) == 1:
                return abs(cards[0] - 24) < 1e-6
            n = len(cards)
            for i in range(n):
                for j in range(n):
                    if i == j:
                        continue
                    a, b = cards[i], cards[j]
                    next_cards = []
                    for k in range(n):
                        if k != i and k != j:
                            next_cards.append(cards[k])
                    # 加法和乘法具有交换律，只需考虑一次
                    for op in '+-*/':
                        if op == '+':
                            if i > j:
                                continue  # 避免重复
                            next_cards_append = next_cards + [a + b]
                            if dfs(next_cards_append):
                                return True
                        elif op == '*':
                            if i > j:
                                continue  # 避免重复
                            next_cards_append = next_cards + [a * b]
                            if dfs(next_cards_append):
                                return True
                        elif op == '-':
                            next_cards_append = next_cards + [a - b]
                            if dfs(next_cards_append):
                                return True
                        elif op == '/':
                            if abs(b) < 1e-6:
                                continue
                            next_cards_append = next_cards + [a / b]
                            if dfs(next_cards_append):
                                return True
            return False
        
        return dfs(cards)
```