# [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)
## 堆
```python
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        pq = [] # 小顶堆,pq[0]维护最小的数字
        for x in nums:
            heappush(pq, x)
            if len(pq)>k:
                heappop(pq) # 把小数字pop走
        return pq[0]
```
## 快排
```python fold
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        def quick(l:int, r:int, k:int)->int:
            if l>=r:
                return nums[l]
            
            pivot = nums[l+r>>1]
            i, j = l-1, r+1

            while i<j:
                # 找到左部分<=pivot的
                while True:
                    i+=1
                    if nums[i] <= pivot:
                        break
                # 找到右部分>=pivot的
                while True:
                    j-=1
                    if nums[j] >= pivot:
                        break
                if i<j:
                    nums[i],nums[j]=nums[j],nums[i] # 快排喜欢的操作
            
            cnt = j-l+1 # 左半有多少数
            if cnt>=k:
                return quick(l,j,k)
            else:
                return quick(j+1, r, k-cnt)
        n = len(nums)
        return quick(0, n-1, k)
```

# [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)
```python fold
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        q = [1]
        seen = set(q)
        for _ in range(n-1):
            x = heappop(q)
            for y in [2*x, 3*x, 5*x]:
                if y not in seen:
                    seen.add(y)
                    heappush(q, y)
        return q[0]
```

# [2931. 购买物品的最大开销](https://leetcode.cn/problems/maximum-spending-after-buying-items/)
思考：越小的数字越早用完
```python fold
class Solution:
    def maxSpending(self, values: List[List[int]]) -> int:
        m, n = len(values), len(values[0])
        h = []
        for i in range(m):
            for j in range(n):
                heappush(h, values[i][j])
        day = 1
        ans = 0
        while h:
            ans += day * heappop(h)
            day += 1
        return ans
```
# [3066. 超过阈值的最少操作数 II](https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/)
```python
class Solution:
    def minOperations(self, nums: List[int], k: int) -> int:
        ans = 0
        q = SortedList(nums)
        while q[0]<k:
            x = q.pop(0)
            y = q.pop(0)
            q.add(min(x,y)*2+max(x,y))
            ans += 1
        return ans
```
# [1792. 最大平均通过率](https://leetcode.cn/problems/maximum-average-pass-ratio/)
一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 `classes` ，其中 `classes[i] = [passi, totali]` ，表示你提前知道了第 `i` 个班级总共有 `totali` 个学生，其中只有 `passi` 个学生可以通过考试。

给你一个整数 `extraStudents` ，表示额外有 `extraStudents` 个聪明的学生，他们 **一定** 能通过任何班级的期末考。你需要给这 `extraStudents` 个学生每人都安排一个班级，使得 **所有** 班级的 **平均** 通过率 **最大** 。

一个班级的 **通过率** 等于这个班级通过考试的学生人数除以这个班级的总人数。**平均通过率** 是所有班级的通过率之和除以班级数目。

请你返回在安排这 `extraStudents` 个学生去对应班级后的 **最大** 平均通过率。与标准答案误差范围在 `10-5` 以内的结果都会视为正确结果。

- 随着增加的学生越来越多，通过率的**增量**是递减（非递增）的。

类似合并k个sort链表
- 创建一个最大堆，堆中保存各个班级的下一个增量以及当前通过率（分子和分母）。
- 谁的下一个增量最大，谁就在堆顶。
- 循环 extraStudents 次。每次把堆顶弹出，分子分母各增加一，计算下一个增量，再重新入堆。

```python
class Solution:
    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:
        # 我们来计算一下增加一个extraStudents后，平均通过率的变化
        h = []
        for p, t in classes:
            heappush(h, (-(p+1)/(t+1) + p/t, p, t)) # 维持最大堆
        for _ in range(extraStudents):
            _, p, t = heappop(h)
            p += 1
            t += 1
            heappush(h, (-(p+1)/(t+1) + p/t, p, t))
        return sum(p/t for _, p, t in h) / len(h)
```