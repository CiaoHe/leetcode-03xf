# [624. 数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)
```python
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        m = len(arrays)
        # 从两个不同数组中选择两个数字（每个数组选一个）计算他们的距离
        mn = arrays[0][0]
        mx = arrays[0][-1]
        res = 0
        for i in range(1, m):
            res = max(res, mx - arrays[i][0], arrays[i][-1] - mn)
            mn = min(mn, arrays[i][0])
            mx = max(mx, arrays[i][-1])
        return res
```
# [2874. 有序三元组中的最大值 II](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/)
给你一个下标从 **0** 开始的整数数组 `nums` 。

请你从所有满足 `i < j < k` 的下标三元组 `(i, j, k)` 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 `0` 。

**下标三元组** `(i, j, k)` 的值等于 `(nums[i] - nums[j]) * nums[k]` 。

- `(nums[i] - nums[j]) * nums[k]` 最大，等价于求nums[i]和nums[j]最大
- 构造出sufMax (list), 然后枚举右边的同时，维护preMax
```python
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        # (nums[i] - nums[j]) * nums[k] 最大，等价于求nums[i]和nums[j]最大
        n = len(nums)
        ans = 0
        preMax = nums[0]
        sufMax = [0]*(n-1)+[nums[-1]]
        for i in range(n-2,-1,-1):
            sufMax[i] = max(sufMax[i+1], nums[i])
        
        for j in range(1,n-1):
            ans = max(ans, (preMax - nums[j]) * sufMax[j+1])
            preMax = max(preMax, nums[j])
        return ans
            
```
# [2364. 统计坏数对的数目](https://leetcode.cn/problems/count-number-of-bad-pairs/)
采用补集思维
```python
class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        n = len(nums)
        # nums[i] - nums[j] != i - j <=> nums[i] - i != nums[j] - j
        # 统计nums[i] - i的值
        # 设a[i] = nums[i] - i
        # 统计多少a[i] == a[j]
        cnt = Counter(nums[i] - i for i in range(n))
        ans = 0
        for k, v in cnt.items():
            ans += v * (v - 1) // 2
        return n * (n - 1) // 2 - ans
```