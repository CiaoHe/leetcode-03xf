# [624. 数组列表中的最大距离](https://leetcode.cn/problems/maximum-distance-in-arrays/)
```python
class Solution:
    def maxDistance(self, arrays: List[List[int]]) -> int:
        m = len(arrays)
        # 从两个不同数组中选择两个数字（每个数组选一个）计算他们的距离
        mn = arrays[0][0]
        mx = arrays[0][-1]
        res = 0
        for i in range(1, m):
            res = max(res, mx - arrays[i][0], arrays[i][-1] - mn)
            mn = min(mn, arrays[i][0])
            mx = max(mx, arrays[i][-1])
        return res
```
# [2874. 有序三元组中的最大值 II](https://leetcode.cn/problems/maximum-value-of-an-ordered-triplet-ii/)
给你一个下标从 **0** 开始的整数数组 `nums` 。

请你从所有满足 `i < j < k` 的下标三元组 `(i, j, k)` 中，找出并返回下标三元组的最大值。如果所有满足条件的三元组的值都是负数，则返回 `0` 。

**下标三元组** `(i, j, k)` 的值等于 `(nums[i] - nums[j]) * nums[k]` 。

- `(nums[i] - nums[j]) * nums[k]` 最大，等价于求nums[i]和nums[j]最大
- 构造出sufMax (list), 然后枚举右边的同时，维护preMax
```python
class Solution:
    def maximumTripletValue(self, nums: List[int]) -> int:
        # (nums[i] - nums[j]) * nums[k] 最大，等价于求nums[i]和nums[j]最大
        n = len(nums)
        ans = 0
        preMax = nums[0]
        sufMax = [0]*(n-1)+[nums[-1]]
        for i in range(n-2,-1,-1):
            sufMax[i] = max(sufMax[i+1], nums[i])
        
        for j in range(1,n-1):
            ans = max(ans, (preMax - nums[j]) * sufMax[j+1])
            preMax = max(preMax, nums[j])
        return ans
            
```
# [2364. 统计坏数对的数目](https://leetcode.cn/problems/count-number-of-bad-pairs/)
采用补集思维
```python
class Solution:
    def countBadPairs(self, nums: List[int]) -> int:
        n = len(nums)
        # nums[i] - nums[j] != i - j <=> nums[i] - i != nums[j] - j
        # 统计nums[i] - i的值
        # 设a[i] = nums[i] - i
        # 统计多少a[i] == a[j]
        cnt = Counter(nums[i] - i for i in range(n))
        ans = 0
        for k, v in cnt.items():
            ans += v * (v - 1) // 2
        return n * (n - 1) // 2 - ans
```
# [2845. 统计趣味子数组的数目](https://leetcode.cn/problems/count-of-interesting-subarrays/)
给你一个下标从 **0** 开始的整数数组 `nums` ，以及整数 `modulo` 和整数 `k` 。

请你找出并统计数组中 **趣味子数组** 的数目。

如果 **子数组** `nums[l..r]` 满足下述条件，则称其为 **趣味子数组** ：

- 在范围 `[l, r]` 内，设 `cnt` 为满足 `nums[i] % modulo == k` 的索引 `i` 的数量。并且 `cnt % modulo == k` 。

以整数形式表示并返回趣味子数组的数目。

**注意：**子数组是数组中的一个连续非空的元素序列。

```python
class Solution:
    def countInterestingSubarrays(self, nums: List[int], modulo: int, k: int) -> int:
        # 转化成arr, 使得arr[i] % modulo == k
        arr = [0] * len(nums)
        for i in range(len(nums)):
            arr[i] = nums[i] % modulo == k
        
        
        # 用前缀和来计算[l, r] 区间内arr[i] % modulo == k 的个数, s[r] - s[l]
        cnt = Counter()  # 记录前缀和s mod modulo 的个数
        cnt[0] = 1

        s = 0
        res = 0
        # (s[r]-k) mod modulo = s[l] mod modulo
        for i, x in enumerate(arr):
            s += x
            if s>=k:
                res += cnt[(s - k) % modulo]
            cnt[s % modulo] += 1
        return res
```

# [3025. 人员站位的方案数 I](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-i/)
3027的弱化版本
给你一个  `n x 2` 的二维数组 `points` ，它表示二维平面上的一些点坐标，其中 `points[i] = [xi, yi]` 。

计算点对 `(A, B)` 的数量，其中

- `A` 在 `B` 的左上角，并且
- 它们形成的长方形中（或直线上）没有其它点（**包括边界**）。

返回数量。

O(n^3)
```python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        n = len(points)
        ans = 0
        for i in range(n):
            x1, y1 = points[i]
            for j in range(n):
                if i == j:
                    continue
                x2, y2 = points[j]
                # Check if (x1, y1) is upper-left and (x2, y2) is lower-right
                if x1 <= x2 and y1 >= y2:
                    valid = True
                    # Check if no other point is inside the rectangle
                    for k in range(n):
                        if k == i or k == j:
                            continue
                        x, y = points[k]
                        if x1 <= x <= x2 and y2 <= y <= y1:
                            valid = False
                            break
                    if valid:
                        ans += 1
        return ans
```
# [3027. 人员站位的方案数 II](https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/)
给你一个  `n x 2` 的二维数组 `points` ，它表示二维平面上的一些点坐标，其中 `points[i] = [xi, yi]` 。

我们定义 x 轴的正方向为 **右** （**x 轴递增的方向**），x 轴的负方向为 **左** （**x 轴递减的方向**）。类似的，我们定义 y 轴的正方向为 **上** （**y 轴递增的方向**），y 轴的负方向为 **下** （**y 轴递减的方向**）。

你需要安排这 `n` 个人的站位，这 `n` 个人中包括 Alice 和 Bob 。你需要确保每个点处 **恰好** 有 **一个** 人。同时，Alice 想跟 Bob 单独玩耍，所以 Alice 会以 Alice 的坐标为 **左上角** ，Bob 的坐标为 **右下角** 建立一个矩形的围栏（**注意**，围栏可能 **不** 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 **内部** 或者 **边缘** 上有任何其他人，Alice 都会难过。

请你在确保 Alice **不会** 难过的前提下，返回 Alice 和 Bob 可以选择的 **点对** 数目。

**注意**，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 `(1, 1)` ，`(1, 3)` ，`(3, 1)` 和 `(3, 3)` 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：

- 图一中，Alice 在 `(3, 3)` 且 Bob 在 `(1, 1)` ，Alice 的位置不是左上角且 Bob 的位置不是右下角。
- 图二中，Alice 在 `(1, 3)` 且 Bob 在 `(1, 1)` ，Bob 的位置不是在围栏的右下角。

![](https://assets.leetcode.com/uploads/2024/01/04/example0alicebob-1.png)

**示例 1：**

![](https://assets.leetcode.com/uploads/2024/01/04/example1alicebob.png)

**输入：**points = [[1,1],[2,2],[3,3]]
**输出：**0
**解释：**没有办法可以让 Alice 的围栏以 Alice 的位置为左上角且 Bob 的位置为右下角。所以我们返回 0

```python
class Solution:
    def numberOfPairs(self, points: List[List[int]]) -> int:
        n = len(points)
        points.sort(key=lambda x: (x[0], -x[1])) # sort by x, then by y in descending order
        ans = 0
        # enumerate all upper-left and lower-right points
        for i in range(n):
            x1, y1 = points[i]
            max_y = -inf # 记录当前矩形内最大的y
            for j in range(i+1, n):
                x2, y2 = points[j]
                if y2 > y1: # y2不能超过y1
                    continue
                if y2 <= max_y:
                    continue # 如果y2不能超过当前最大的max_y, 那么证明在他之前有一个y2在更上方, invalid
                ans += 1
                max_y = y2
        return ans
```

# [3381. 长度可被 K 整除的子数组的最大元素和](https://leetcode.cn/problems/maximum-subarray-sum-with-length-divisible-by-k/)
给你一个整数数组 `nums` 和一个整数 `k` 。
返回 `nums` 中一个 非空子数组 的 **最大** 和，要求该子数组的长度可以 **被** `k` **整除**。

> 首先想到前缀和
> 然后想到需要遍历$[i,j)$ 区间 且 (j-i) % k == 0
> 但是两重遍历会超时，所以最好枚举右边j 然后维护左边i，那么这个左边i需要做的是尽可能维护最小的前缀和
```python
class Solution:
    def maxSubarraySum(self, nums: List[int], k: int) -> int:
        # maintain a prefix sum array
        pre = list(accumulate(nums, initial=0))
        # 我们遍历pre (j为index)，希望找到 [i,j)的最大和区间
        # 那么尽可能希望pre[i]小，所以我们需要维护一个通过j%k可以映射到最小pre[i]的数据结构
        min_s = [inf] * k # 满足i<j且i与j关于k同余的pre[i]的最小值
        ans = -inf
        for j,s in enumerate(pre):
            i = j % k
            ans = max(ans, s - min_s[i])
            min_s[i] = min(min_s[i], s)
        return ans
```