# 模版
## merge模版
```python
def merge(a, b)->None:
	# 一般以b为准
	fa = find(a)
	fb = find(b)
	if fb!=fa:
		self.fa[fa] = fb
```

## find模版
非递归形式
```python
fa = list(range(n))
def find(x:int)->int:
	rt = x
	while fa[rt]!=rt:
		rt = fa[rt]
	while fa[x] != rt:
		fa[x], x = rt, fa[x]
	return rt
```
递归形式
```python
fa = list(range(n))
def find(x:int)->int:
	root = x
	# 找到祖宗
	while fa[root]!=root:
		root = fa[root]
	# 所有人 认祖归宗
	while x != root:
		orig_fa_x = fa[x]
		fa[x] = root
		x = orig_fa_x
	return root
```
## 操作步骤
1. 先尽可能merge
2. 然后再每一条进行find 来做update
## class模版
```python
class UnionFind:
    def __init__(self, n):
        self.fa = list(range(n))

    def find(self, x):
        if self.fa[x] != x:
            self.fa[x] = self.find(self.fa[x])
        return self.fa[x]

    def union(self, x, y):
        self.fa[self.find(x)] = self.find(y)

    def connected(self, x, y):
        return self.find(x) == self.find(y)
```

# [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)
- 并查集做法
```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        uf = UnionFind(n)
        for i in range(n):
            for j in range(i + 1, n):
                if isConnected[i][j]:
                    uf.union(i, j)
        for i in range(n):
            uf.find(i)
        return len(set(uf.fa))
```
* DFS做法
```python fold
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        # dfs
        n = len(isConnected)
        visited = [False] * n

        def dfs(i):
            visited[i] = True
            for j in range(n):
                if isConnected[i][j] == 1 and not visited[j]:
                    dfs(j)

        ans = 0
        for i in range(n):
            if not visited[i]:
                dfs(i)
                ans += 1
        return ans

```
# [3607. 电网维护](https://leetcode.cn/problems/power-grid-maintenance/)
给你一个整数 `c`，表示 `c` 个电站，每个电站有一个唯一标识符 `id`，从 1 到 `c` 编号。

这些电站通过 `n` 条 **双向** 电缆互相连接，表示为一个二维数组 `connections`，其中每个元素 `connections[i] = [ui, vi]` 表示电站 `ui` 和电站 `vi` 之间的连接。直接或间接连接的电站组成了一个 **电网** 。

最初，**所有** 电站均处于在线（正常运行）状态。

另给你一个二维数组 `queries`，其中每个查询属于以下 **两种类型之一** ：

- `[1, x]`：请求对电站 `x` 进行维护检查。如果电站 `x` 在线，则它自行解决检查。如果电站 `x` 已离线，则检查由与 `x` 同一 **电网** 中 **编号最小** 的在线电站解决。如果该电网中 **不存在** 任何 **在线** 电站，则返回 -1。
    
- `[2, x]`：电站 `x` 离线（即变为非运行状态）。
    

返回一个整数数组，表示按照查询中出现的顺序，所有类型为 `[1, x]` 的查询结果。

**注意：**电网的结构是固定的；离线（非运行）的节点仍然属于其所在的电网，且离线操作不会改变电网的连接性。


```python
class UnionFind:
    def __init__(self, n):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]
    
    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px == py:
            return False
        if self.size[px] > self.size[py]:
            self.p[py] = px
            self.size[px] += self.size[py]
        else:
            self.p[px] = py
            self.size[py] += self.size[px]
        return True
    
class Solution:
    def processQueries(self, c: int, connections: List[List[int]], queries: List[List[int]]) -> List[int]:
        uf = UnionFind(c+1)
        for u, v in connections:
            uf.union(u, v)
        
        # 用sortedlist维护一个结构 可以快速找到component最小数
        st = [SortedList() for _ in range(c+1)]
        for i in range(1, c+1):
            st[uf.find(i)].add(i)

        ans = []
        for type_, x in queries:
            root = uf.find(x)
            if type_ == 1:
                if x in st[root]:
                    ans.append(x)
                # 如果x不在st[root]中，则需要找到x的下一个数
                elif len(st[root]) > 0:
                    ans.append(st[root][0])
                else:
                    ans.append(-1)
            elif type_ == 2:
                st[root].discard(x)
        return ans
```