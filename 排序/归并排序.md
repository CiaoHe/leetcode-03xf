# [LCR 170. 交易逆序对的总数](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)
逆序对定义：`record[i] > record[j] 且 i < j。`
核心思想：利用归并排序的分治思想，在合并两个有序数组时统计逆序对数量。
归并排序步骤：
1. 递归地将数组分成左右两部分，分别排序并统计逆序对。
2. 合并时，若右半部分当前元素小于左半部分当前元素，则左半部分剩余元素都与右半部分当前元素构成逆序对。

关键点：
1. 在合并过程中，统计跨越左右部分的逆序对数量。
2. 临时数组 `tmp` 辅助合并，避免修改原数组影响后续比较。
```python fold
class Solution:
    def reversePairs(self, record: List[int]) -> int:
        tmp = [0] * len(record)
        def merge_sort(l, r):
            if l >= r:
                return 0
            mid = (l + r) // 2
            left = merge_sort(l, mid)
            right = merge_sort(mid + 1, r)
            res = left + right

            i, j = l, mid + 1
            tmp[l:r+1] = record[l:r+1]
            for k in range(l, r+1): # 合并两个有序数组. k是目标数组的下标
                if i == mid + 1: # 左数组已经遍历完
                    record[k] = tmp[j]
                    j += 1
                elif j == r + 1: # 右数组已经遍历完
                    record[k] = tmp[i]
                    i += 1
                elif tmp[i] <= tmp[j]: # 左数组当前元素小于右数组当前元素
                    record[k] = tmp[i]
                    i += 1
                else: # 右数组当前元素小于左数组当前元素
                    record[k] = tmp[j]
                    j += 1
                    # 计算跨越左右部分的逆序对数量
                    res += mid - i + 1
            return res
        return merge_sort(0, len(record) - 1)
```