# [2338. 统计理想数组的数目](https://leetcode.cn/problems/count-the-number-of-ideal-arrays/)

｜ 初始理解题目

首先，我们需要清楚地理解题目在说什么。题目给出了两个整数 `n` 和 `maxValue`，要求我们构造一个长度为 `n` 的数组 `arr`，满足以下条件：

1. 每个 `arr[i]` 的值在 `1` 到 `maxValue` 之间（包括 `1` 和 `maxValue`）。
2. 对于 `i > 0`，`arr[i]` 必须能被 `arr[i - 1]` 整除。

我们需要计算所有满足这些条件的不同的 `arr` 的数量，由于数量可能很大，所以结果需要对 `10^9 + 7` 取模。

｜  观察模式

从上面的例子中，我们可以观察到：

1. 数组的第一个元素 `a0` 可以是 `1` 到 `maxValue` 的任何数。
2. 对于 `i > 0`，`arr[i]` 必须是 `arr[i - 1]` 的倍数。
3. 因此，整个数组实际上是一个“倍数链”，即 `a0 | a1 | a2 | ... | a(n-1)`，其中 `|` 表示“整除”。

｜ 动态规划的思路

为了计算所有可能的理想数组的数量，可以考虑动态规划（DP）的方法。我们可以定义 `dp[i][k]` 表示长度为 `i` 的数组，最后一个元素是 `k` 的理想数组的数量。

那么，状态转移方程可以这样考虑：

- 对于 `dp[i][k]`，它的前一个元素 `m` 必须是 `k` 的因数（因为 `m | k`）。
- 因此，`dp[i][k]` 可以表示为所有 `dp[i-1][m]` 的和，其中 `m` 是 `k` 的因数。

初始条件是 `dp[1][k] = 1` 对于所有 `1 <= k <= maxValue`。
最终答案是所有 `dp[n][k]` 的和，其中 `1 <= k <= maxValue`。

粗暴的解法 二维DP
```python
class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        MOD = 10**9 + 7
        # DP, dp[i][k]: 表示遍历了i个元素，最后一个元素是k 的理想数组的个数
        # 最后返回dp[n][1] + dp[n][2] + ... + dp[n][maxValue]
        dp = [[0] * (maxValue + 1) for _ in range(n + 1)]
        # 初始化 dp[1][k] = 1, 因为只有一个元素 理想数组个数为1
        for k in range(1, maxValue + 1):
            dp[1][k] = 1
        # 转移: dp[i][k] =  sum_{d | k} dp[i-1][d]
        for i in range(2, n + 1):
            for k in range(1, maxValue + 1):
                for d in range(1, k+1):
                    if k % d == 0:
                        dp[i][k] = (dp[i][k] + dp[i-1][d]) % MOD
        # 最后返回dp[n][1] + dp[n][2] + ... + dp[n][maxValue]
        return sum(dp[n]) % MOD
```
进一步加速，可以提前计算好所有数字的质因数。同时省去第一个维度的DP
```python
class Solution:
    def idealArrays(self, n: int, maxValue: int) -> int:
        MOD = 10**9 + 7
        
        # Precompute divisors for each number up to maxValue
        divisors = [[] for _ in range(maxValue + 1)] # 保存所有数的质因数
        for d in range(1, maxValue + 1):
            for multiple in range(d, maxValue + 1, d):
                divisors[multiple].append(d)
        
        # Initialize DP, 这部分和上面的做法相同
        dp_prev = [0] * (maxValue + 1)
        for k in range(1, maxValue + 1):
            dp_prev[k] = 1
        
        for i in range(2, n + 1):
            dp_curr = [0] * (maxValue + 1)
            for k in range(1, maxValue + 1):
                for d in divisors[k]: # 快速拿到所有的质因数
                    dp_curr[k] = (dp_curr[k] + dp_prev[d]) % MOD
            dp_prev = dp_curr
        
        return sum(dp_prev) % MOD
```