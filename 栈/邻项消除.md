# [1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)
用stack去记录(char, cnt), 如果cnt到达k次那么就可以pop掉
```python
class Solution:
    def removeDuplicates(self, s: str, k: int) -> str:
        st = [] # (char, cnt)
        for c in s:
            if st and st[-1][0] == c:
                st[-1][1] += 1
                # if occurrence is k, pop
                if st[-1][1] == k:
                    st.pop()
            else:
                st.append([c, 1])
        return ''.join(c*cnt for c,cnt in st)
```
# [面试题 01.06. 字符串压缩](https://leetcode.cn/problems/compress-string-lcci/)
受到[[1209. 删除字符串中的所有相邻重复项 II](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/)](#[1209.%20删除字符串中的所有相邻重复项%20II](https%20//leetcode.cn/problems/remove-all-adjacent-duplicates-in-string-ii/))启发
```python 
class Solution:
    def compressString(self, S: str) -> str:
        st = []
        for c in S:
            if st and st[-1][0] == c:
                st[-1][1] += 1
            else:
                st.append([c, 1])
        tmp = "".join(f"{c}{cnt}" for c, cnt in st)
        return tmp if len(tmp) < len(S) else S
```

# [1717. 删除子字符串的最大得分](https://leetcode.cn/problems/maximum-score-from-removing-substrings/)
给你一个字符串 `s` 和两个整数 `x` 和 `y` 。你可以执行下面两种操作任意次。

- 删除子字符串 `"ab"` 并得到 `x` 分。
    - 比方说，从 `"c**ab**xbae"` 删除 `ab` ，得到 `"cxbae"` 。
- 删除子字符串`"ba"` 并得到 `y` 分。
    - 比方说，从 `"cabx**ba**e"` 删除 `ba` ，得到 `"cabxe"` 。

请返回对 `s` 字符串执行上面操作若干次能得到的最大得分。


带有一定的贪心
1. ​**​优先处理高价值组合​**​：根据x和y的大小关系，决定先处理"ab"还是"ba"组合。这样可以最大化收益。
2. ​**​两次处理字符串​**​：第一次处理高价值组合，第二次处理剩下的低价值组合。
3. ​**​使用栈来匹配​**​：利用栈来高效地匹配和删除字符组合。
```python
class Solution:
    def maximumGain(self, s: str, x: int, y: int) -> int:
        def calculate(s, first, second, value):
            st = []
            res = 0
            for c in s:
                if c == second:
                    if st and st[-1] == first:
                        st.pop()
                        res += value
                    else:
                        st.append(c)
                else:
                    st.append(c)
            return res, ''.join(st)

        if x>=y:
            # 先处理ab
            ab_value, remain = calculate(s, 'a', 'b', x)
            ba_value, remain = calculate(remain, 'b', 'a', y)
            return ab_value + ba_value
        else:
            # 先处理ba
            ba_value, remain = calculate(s, 'b', 'a', y)
            ab_value, remain = calculate(remain, 'a', 'b', x)
            return ba_value + ab_value
```