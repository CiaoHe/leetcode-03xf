# [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
```python fold
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix[0])
        ans = []
        top, bottom, left, right = 0, m-1, 0, n-1
        while top <= bottom and left <= right:
            for i in range(left, right+1):
                ans.append(matrix[top][i])
            top += 1
            for j in range(top, bottom+1):
                ans.append(matrix[j][right])
            right -= 1
            # check whether meet the bottom
            if top <= bottom:
                for i in range(right, left-1, -1):
                    ans.append(matrix[bottom][i])
                bottom -= 1
            # check whether meet the left
            if left <= right:
                for j in range(bottom, top-1, -1):
                    ans.append(matrix[j][left])
                left += 1
        return ans
```
# [1706. 球会落何处](https://leetcode.cn/problems/where-will-the-ball-fall/)
```python
class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])
        res = []
        for i in range(n):
            x, y = 0, i
            stuck = False
            while x < m:
                if grid[x][y] == 1:
                    # 如果右边就是-1，卡住; 或者已经到最右边了
                    if y + 1 < n and grid[x][y + 1] == -1 or y + 1 >= n:
                        stuck = True
                        res.append(-1)
                        break
                    x += 1
                    y += 1
                else:
                    # 如果左边就是1，卡住； 或者已经到最左边了
                    if y - 1 >= 0 and grid[x][y - 1] == 1 or y - 1 < 0:
                        stuck = True
                        res.append(-1)
                        break
                    x += 1
                    y -= 1
            if not stuck:
                res.append(y)
        return res
```
# [498. 对角线遍历](https://leetcode.cn/problems/diagonal-traverse/)
给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

```python
class Solution:
    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:
        m, n = len(mat), len(mat[0])
        ans = []
        for k in range(m+n-1):
            # j=k-i, i取最大值是m-1, 所以j的最小值是k-(m-1)
            min_j = max(0, k-m+1)
            # i取最小值0, 那么j的最大值在k,n-1里选择最小的
            max_j = min(k, n-1)
            # 需要满足i+j=k
            # 锁定k 知道j就等于知道i
            if k%2==1:
                # 逆过来
                for j in range(max_j, min_j-1, -1):
                    ans.append(mat[k-j][j])
            else:
                for j in range(min_j, max_j+1):
                    ans.append(mat[k-j][j])
        return ans
```
# [3446. 按对角线进行矩阵排序](https://leetcode.cn/problems/sort-matrix-by-diagonals/)
模版题目：遍历对角线(i-j是固定值)

给你一个大小为 `n x n` 的整数方阵 `grid`。返回一个经过如下调整的矩阵：

- **左下角三角形**（包括中间对角线）的对角线按 **非递增顺序** 排序。
- **右上角三角形** 的对角线按 **非递减顺序** 排序。

```python
class Solution:
    def sortMatrix(self, grid: List[List[int]]) -> List[List[int]]:
        n = len(grid)
        # 左下角三角形（包括中间对角线）的对角线按 非递增顺序 排序。
        # 右上角三角形（包括中间对角线）的对角线按 非递减顺序 排序。
        # k = i-j+n 范围在 [1, 2n-1]
        for k in range(1, 2*n):
            # j = n+i-k
            # min_j 在 i=0的时候可以取到
            # max_j 在 i=n-1的时候可以取到
            min_j = max(0, n-k)
            max_j = min(n-1, 2*n-k-1)
            # 对角线上的元素
            diag = []
            for j in range(min_j, max_j+1):
                diag.append(grid[j+k-n][j])
            diag.sort(reverse=min_j==0) # 若果min_j是>0, 证明是右上三角 需要reverse sort
            for j,val in zip(range(min_j, max_j+1), diag):
                grid[j+k-n][j] = val
        return grid
```
# [166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/)
给定两个整数，分别表示分数的分子 `numerator` 和分母 `denominator`，以 **字符串形式返回小数** 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 **任意一个** 。

对于所有给定的输入，**保证** 答案字符串的长度小于 `10^4` 。

```python
class Solution:
    def fractionToDecimal(self, numerator: int, denominator: int) -> str:
        if numerator == 0:
            return "0"
        if numerator * denominator < 0:
            sign = "-"
        else:
            sign = ""
        numerator = abs(numerator)
        denominator = abs(denominator)
        integer = numerator // denominator
        numerator %= denominator
        decimal = []
        seen = {} # 记录循环小数的位置
        while numerator != 0:
            if numerator in seen: # 进入循环，说明是循环小数
                decimal.insert(seen[numerator], "(")
                decimal.append(")")
                break
            # 滚动
            seen[numerator] = len(decimal)
            numerator *= 10
            decimal.append(str(numerator // denominator))
            numerator %= denominator
        
        if decimal:
            return sign + str(integer) + "." + "".join(decimal)
        else:
            return sign + str(integer)
```