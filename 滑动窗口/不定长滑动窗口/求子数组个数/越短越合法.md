>[! 总结]
一般要写 `ans += right - left + 1`。  
滑动窗口的内层循环结束时，右端点**固定**在 $\textit{right}$，左端点在 $\textit{left},\textit{left}+1,\ldots,\textit{right}$ 的所有子数组（子串）都是合法的，这一共有 $\textit{right}-\textit{left}+1$ 个。
#  [3258. 统计满足 K 约束的子字符串数量 I](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-i/)
```python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int) -> int:
        n = len(s)
        # sliding window
        ans = 0
        l = 0
        cnt = [0,0]
        for r,x in enumerate(map(int,s)):
            cnt[x] += 1
            # 关键部分来了:
            while cnt[0]>k and cnt[1]>k:
                # maintain 区间
                pop_item = int(s[l])
                l+=1
                cnt[pop_item]-=1
            # 第二个关键部分：统计有效子字符串数目: [l,r]都是=> r-l+1
            ans += r-l+1
        return ans
```

#  [3261. 统计满足 K 约束的子字符串数量 II](https://leetcode.cn/problems/count-substrings-that-satisfy-k-constraint-ii/) 
前缀和 + diff
```python
class Solution:
    def countKConstraintSubstrings(self, s: str, k: int, queries: List[List[int]]) -> List[int]:
        n = len(s)
        pre = [0]*(n+1) # 前缀和：pre[i+1]: 以i-th为右边界的有效子串数目
        d = [n]*n # d[i]: 以i-th为左边界，最近的不满足有效性的右边界
        l=0
        cnt=[0,0]
        for i,x in enumerate(map(int, s)):
            cnt[x]+=1
            while cnt[0]>k and cnt[1]>k:
                d[l] = i
                cnt[int(s[l])]-=1
                l+=1
            # update前缀和
            pre[i+1] = pre[i] + (i-l+1)
        
        ans = []
        for l,r in queries:
            # p: 以l-th为左边届，最远能够保证有效性的边界
            p = min(d[l]-1, r)
            # 第一部分：[l,p]
            a = (p-l+2)*(p-l+1)//2
            # 第二部分: [p+1, r]
            b = pre[r+1]-pre[p+1]
            
            ans.append(a+b)
        return ans
```
# [2348. 全 0 子数组的数目](https://leetcode.cn/problems/number-of-zero-filled-subarrays/)
给你一个整数数组 `nums` ，返回全部为 `0` 的 **子数组** 数目。

**子数组** 是一个数组中一段连续非空元素组成的序列。

```python
class Solution:
    def zeroFilledSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        ans = 0
        i = 0
        while i < n:
            # 固定左端点
            if nums[i] != 0:
                i += 1
                continue
            j = i
            while j < n and nums[j] == 0:
                j += 1
            ans += (j - i) * (j - i + 1) // 2
            i = j
        return ans
```

# [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)
给你一个二进制数组 `nums` ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

```python
class Solution:
    def longestSubarray(self, nums: List[int]) -> int:
        n = len(nums)
        if sum(nums) == n:
            return n-1
        
        # 问题转化：找到至多有1个0的最长子数组
        # 滑动窗口
        ans = 0
        cnt0 = 0
        left = 0
        for right, x in enumerate(nums):
            if x == 0:
                cnt0 += 1
            while cnt0 > 1:
                if nums[left] == 0:
                    cnt0 -= 1
                left += 1
            ans = max(ans, right-left) # 因为需要减去1个0
        return ans
```