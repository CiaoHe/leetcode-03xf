>[! 总结]
>一般要写 `ans += left`。
滑动窗口的内层循环结束时，右端点**固定**在 $\textit{right}$，左端点在 $0,1,2,\ldots,\textit{left}-1$ 的所有子数组（子串）都是合法的，这一共有 $\textit{left}$ 个。
# [1358. 包含所有三种字符的子字符串数目](https://leetcode.cn/problems/number-of-substrings-containing-all-three-characters/)
- 开 三个 cnter
```python
class Solution:
    def numberOfSubstrings(self, s: str) -> int:
        a = b = c = 0
        res = 0
        left = 0
        for right, x in enumerate(s):
            if x == 'a':
                a += 1
            elif x == 'b':
                b += 1
            else:
                c += 1
            while a and b and c:
                if s[left] == 'a':
                    a -= 1
                elif s[left] == 'b':
                    b -= 1
                else:
                    c -= 1
                left += 1
            res += left
        return res
```
# [3325. 字符至少出现 K 次的子字符串 I](https://leetcode.cn/problems/count-substrings-with-k-frequency-characters-i/)
```python
class Solution:
    def numberOfSubstrings(self, s: str, k: int) -> int:
        cnter = Counter()
        res = 0
        left = 0
        for right, x in enumerate(s):
            cnter[x] += 1
            while max(cnter.values()) >= k:
                cnter[s[left]] -= 1
                left += 1
            res += left
        return res
```
# [2799. 统计完全子数组的数目](https://leetcode.cn/problems/count-complete-subarrays-in-an-array/)
`[0, left)` 是满足条件的子数组
```python
class Solution:
    def countCompleteSubarrays(self, nums: List[int]) -> int:
        total_diff = len(set(nums))
        left = 0
        res = 0
        cnter = Counter()
        for right, x in enumerate(nums):
            cnter[x] += 1
            while len(cnter) == total_diff:
                cnter[nums[left]] -= 1
                if cnter[nums[left]] == 0:
                    del cnter[nums[left]]
                left += 1
            res += left
        return res
```
# [2962. 统计最大元素出现至少 K 次的子数组](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/)
直接hash
```python
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        mx = max(nums)
        res = 0
        left = 0
        cnter = Counter()
        for right, x in enumerate(nums):
            cnter[x] += 1
            while cnter[mx] >= k:
                cnter[nums[left]] -= 1
                left += 1
            res += left
        return res
```
- 因为我们只关心 `mx`, 可以只统计 `mx` 出现的次数
```python
class Solution:
    def countSubarrays(self, nums: List[int], k: int) -> int:
        mx = max(nums)
        res = 0
        left = 0
        cnt_mx = 0
        for right, x in enumerate(nums):
            if x == mx:
                cnt_mx += 1
            while cnt_mx >= k:
                if nums[left] == mx:
                    cnt_mx -= 1
                left += 1
            res += left
        return res
```

# [2537. 统计好子数组的数目](https://leetcode.cn/problems/count-the-number-of-good-subarrays/)
核心：
- 如何快速计算出substring中pair的个数？或者说如何全局去维护一个pair number ?
```python
class Solution:
    def countGood(self, nums: List[int], k: int) -> int:
        res = 0
        # 双指针
        left = 0 # 维护子数组左边
        cnter = Counter()

        pairs = 0 # 子数组范围内的数对
        for right, x in enumerate(nums):
            pairs += cnter[x] # 统计当前右边的数和左边的数形成的对数
            cnter[x] += 1 # 统计当前右边的数
            while pairs >= k:
                cnter[nums[left]] -= 1 # 收缩左边届
                pairs -= cnter[nums[left]]
                left += 1
            res += left # 当确定有边界时，左边界[0,left-1]都是合法的，所以整体数目+=left
        return res
```
# [3298. 统计重新排列后包含另一个字符串的子字符串数目 II](https://leetcode.cn/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii/)
要返回所有valid的数目
- 本题对space / time 有限制，尽量少用 `Counter`
- 用hash来维护 两个串 的差异
```python
class Solution:
    def validSubstringCount(self, word1: str, word2: str) -> int:
        s,t = word1,word2
        if len(s)<len(t):
            return 0
        diff = defaultdict(int)
        for c in t:
            diff[c] += 1
        less = len(diff) # 窗口内有多少个字母不满额

        ans = 0
        left = 0
        for j,c in enumerate(s):
            diff[c] -= 1
            while max(diff.values()) <= 0:# valid window
                # 收缩left
                diff[s[left]] += 1
                left += 1
            ans += left # [0, ..., left-1]都满足，一共left个
        return ans
```
# [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/)
你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

> 人话: 挑选子数组，里面至多有两种数字

```python
class Solution:
    def totalFruit(self, fruits: List[int]) -> int:
        ans = 0
        i = 0
        cnt = Counter()
        for j,x in enumerate(fruits):
            cnt[x] += 1
            while len(cnt) > 2:
                cnt[fruits[i]] -= 1
                if cnt[fruits[i]] == 0:
                    del cnt[fruits[i]]
                i += 1
            ans = max(ans, j - i + 1)
        return ans
```