本质上和不相交区间是一样的。
# [452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)
经典吹箭
按照需求刷新箭矢的伤害范围
```python fold
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points.sort(key=lambda x: x[1])
        arrows = 1
        _, b = points[0]
        for start, end in points[1:]:
            if start > b:
                arrows += 1
                b = end
        return arrows
```

# [757. 设置交集大小至少为2](https://leetcode.cn/problems/set-intersection-size-at-least-two/)
给你一个二维整数数组 `intervals` ，其中 `intervals[i] = [starti, endi]` 表示从 `starti` 到 `endi` 的所有整数，包括 `starti` 和 `endi` 。

**包含集合** 是一个名为 `nums` 的数组，并满足 `intervals` 中的每个区间都 **至少** 有 **两个** 整数在 `nums` 中。

- 例如，如果 `intervals = [[1,3], [3,7], [8,9]]` ，那么 `[1,2,4,7,8,9]` 和 `[2,3,4,8,9]` 都符合 **包含集合** 的定义。

返回包含集合可能的最小大小。

> 关键观察
1. **贪心选择**：为了用最少的数覆盖多个区间，我们应该尽量选择那些能同时满足多个区间要求的数。
2. **区间排序**：通常这类问题需要先按区间右端点排序（或按左端点排序，但右端点排序在贪心时更直接）。
3. **两个数的安排**：对每个区间，如果还没满足“至少两个数”的条件，我们优先从区间末尾开始选数，因为末尾的数可能对后续区间也有用。

> 1. 按区间右端点升序排序。
> 2. 初始化一个集合 `chosen`记录已选择的数字。
> 3. 对每个区间 `[start, end]`：
    - 统计该区间内已选的数字个数 `count`（即 `chosen`中在 `[start, end]`的数字个数）。
    - 如果 `count >= 2`，则已满足，跳过。
    - 否则，还需要加入 `2 - count`个新数字。
    - 为了最大化重复利用，从区间右端开始向左选择尚未选过的数字加入 `chosen`，直到满足 2 个。
        
为什么从右端开始选？因为后面的区间右端点更大，选当前区间右端或右端-1 这样的数字，更可能帮助到后面的区间。

```python
class Solution:
    def intersectionSizeTwo(self, intervals: List[List[int]]) -> int:
        # 按照右端点排序+左端点降序
        intervals.sort(key=lambda x: (x[1], -x[0]))
        
        # 记录已经选择的数字
        chosen = []

        for l, r in intervals:
            # 统计该区间内以精选的数字的个数
            cnt = 0
            for x in chosen:
                if l <= x <= r:
                    cnt += 1
                    if cnt >= 2:
                        break
            if cnt == 2:
                continue
            # how to add two numbers to chosen?
            k = 2 - cnt
            for i in range(r, l-1, -1):
                if i not in chosen:
                    chosen.append(i)
                    k -= 1
                    if k == 0:
                        break
        return len(chosen)
```