# [3085. 成为 K 特殊字符串需要删除的最少字符数](https://leetcode.cn/problems/minimum-deletions-to-make-string-k-special/)
给你一个字符串 `word` 和一个整数 `k`。

如果 `|freq(word[i]) - freq(word[j])| <= k` 对于字符串中所有下标 `i` 和 `j`  都成立，则认为 `word` 是 **k 特殊字符串**。

此处，`freq(x)` 表示字符 `x` 在 `word` 中的出现频率，而 `|y|` 表示 `y` 的绝对值。

返回使 `word` 成为 **k 特殊字符串** 需要删除的字符的最小数量

```python
class Solution:
    def minimumDeletions(self, word: str, k: int) -> int:
        cnt = Counter(word)
        freq = sorted(cnt.values())
        n = len(freq)
        res = float('inf')

        prefix_sum = [0] + list(accumulate(freq))
        
        for i in range(n):
            # 选择freq[i]作为最小值
            min_keep = freq[i]
            # 计算删除次数
            # 所有freq<min_keep的元素都需要删除
            del_cnt = prefix_sum[i]
            # 所有freq>min_keep的元素需要删除多余的部分
            for j in range(i+1, n):
                if freq[j] > min_keep + k:
                    del_cnt += freq[j] - (min_keep + k)
            res = min(res, del_cnt)
        return res
```

# [2749. 得到整数零需要执行的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/)
给你两个整数：num1 和 num2 。

在一步操作中，你需要从范围 [0, 60] 中选出一个整数 i ，并从 num1 减去 2i + num2 。

请你计算，要想使 num1 等于 0 需要执行的最少操作数，并以整数形式返回。

如果无法使 num1 等于 0 ，返回 -1 。


我们的目标是让 num1 经过 k 次操作后变成 0。
我们先写出 k 次操作的完整过程：
- **第 1 次操作**: 我们选择一个 i_1，num1 变成 num1 - (2^i_1 + num2)。
- **第 2 次操作**: 我们选择一个 i_2，num1 变成 (num1 - (2^i_1 + num2)) - (2^i_2 + num2)。
- **...**
- **第 k 次操作**: 我们选择一个 i_k，num1 最终变成 0。
把这 k 次操作合并在一个等式里，就是：  
$num1 - (2^{i_1 }+ num2) - (2^{i_2} + num2) - ... - (2^{i_k} + num2) = 0$


1. **括号展开**:  
    num1 - 2^i_1 - num2 - 2^i_2 - num2 - ... - 2^i_k - num2 = 0
2. **重新组合**: 我们可以把所有的 num2 放在一起，把所有的 2 的幂次放在一起。
    - 我们总共进行了 k 次操作，所以有 k 个 - num2。
    - 我们选择了 k 个 2 的幂次，分别是 -2^i_1, -2^i_2, ..., -2^i_k。
    等式就变成了：  
    num1 - (num2 + num2 + ... + num2) - (2^i_1 + 2^i_2 + ... + 2^i_k) = 0
3. **合并同类项**:
    - k 个 num2 相加，就是 k * num2。
    所以等式简化为：  
    num1 - (k * num2) - (2^i_1 + 2^i_2 + ... + 2^i_k) = 0
4. **移项**: 现在，我们把和 2 的幂次相关的部分移到等式的右边。  
    num1 - k * num2 = 2^i_1 + 2^i_2 + ... + 2^i_k

所以，这个等式完美地把原问题转化成了：
> **“是否存在一个操作次数 k，使得 num1 - k * num2 的值，恰好可以被表示成 k 个 2 的幂次之和？”**

```python
class Solution:
    def makeTheIntegerZero(self, num1: int, num2: int) -> int:
        if num1 <= num2:
            return -1
        
        for k in range(1, 60):
            target = num1 - k * num2
            if k > num1 / (num2+1):
                continue
            if target < 0:
                return -1
            # 检查两个关键条件
            # 1. target 中二进制'1'的个数（代表最少需要的2的幂的数量）必须 <= k
            # 2. target 本身必须 >= k（k个2的幂相加，最小值是k个2^0，也就是k）
            if target.bit_count() <= k and k <= target:
                return k
        return -1
```