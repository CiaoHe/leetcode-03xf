
设 `n` 是数组 `a` 的长度，`m` 是出现次数最多的元素的出现次数。

**问题一**

​**​问题描述​**​：给定数组 `a`，能否重新排列其中的元素，使得所有相邻元素均不同？如果能，输出重排后的数组。

​**​答案​**​：
- 如果 `m ≤ n - m + 1`，则可以做到
- 否则无法做到

**问题二**
​**​问题描述​**​：给定数组 `a`，每次操作删除 `a` 中的两个不同元素。最多能操作多少次？

​**​答案​**​：  
最多操作 min(⌊2n​⌋,n−m) 次

**问题三**
​**​问题描述​**​：给定数组 `a`，每次操作删除 `a` 中的至多两个不同元素。最少要操作多少次？

​**​答案​**​：  
最少操作 max(⌈2n​⌉,m) 次

# [3495. 使数组元素都变为零的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-make-array-elements-zero/)
给你一个二维数组 `queries`，其中 `queries[i]` 形式为 `[l, r]`。每个 `queries[i]` 表示了一个元素范围从 `l` 到 `r` （包括 **l** 和 **r** ）的整数数组 `nums` 。

在一次操作中，你可以：

- 选择一个查询数组中的两个整数 `a` 和 `b`。
- 将它们替换为 `floor(a / 4)` 和 `floor(b / 4)`。

你的任务是确定对于每个查询，将数组中的所有元素都变为零的 **最少** 操作次数。返回所有查询结果的总和。


1. **“工作量”**：将一个数字 x 变为0，需要 log4(x) 次“除以4”的操作。我们可以把 log4(x) 看作是数字 x 身上带的“工作量”。
    
2. **总工作量**：对于一个查询 [l, r]，我们需要完成的总工作量就是区间内所有数字的工作量之和，即 TotalWork = sum(log4(i) for i in range(l, r + 1))。
    
3. **操作效率**：我们的一次操作 (a, b) -> (floor(a/4), floor(b/4)) 可以同时减少 a 和 b 的工作量（各减1）。因此，**一次操作可以完成2个单位的总工作量**。
    
4. **最少操作次数**：那么，要完成 TotalWork 的总工作量，最少需要 ceil(TotalWork / 2) 次操作。使用 ceil (向上取整) 是因为如果总工作量是奇数（例如7），我们需要 7/2 = 3.5，也就是4次操作才能全部完成。在整数运算中，ceil(N / 2) 等价于 (N + 1) // 2。

```python
class Solution:
    def minOperations(self, queries: List[List[int]]) -> int:        
        def log4_up_to(x):
            if x == 0:
                return 0
            total_sum = 0
            power_of_4 = 1
            while power_of_4 <= x:
                count = x - power_of_4 + 1
                total_sum += count
                if power_of_4 * 4 <= x:
                    power_of_4 *= 4
                else:
                    break
            return total_sum
        
        ans = 0
        for l,r in queries:
            sum_up_to_r = log4_up_to(r)
            sum_up_to_l = log4_up_to(l-1)
            ans += (sum_up_to_r - sum_up_to_l + 1) // 2
        return ans
```

# [3659. 数组元素分组](https://leetcode.cn/problems/partition-array-into-k-distinct-groups/)
给你一个整数数组 `nums` 和一个整数 `k`。
请你判断是否可以将 `nums` 中的所有元素分成一个或多个组，使得：
- 每个组 **恰好** 包含 `k` 个元素。
- 每组中的元素 **互不相同**。
- `nums` 中的每个元素 **必须** 被分配到 **恰好一个** 组中。
如果可以完成这样的分组，返回 `true`；否则，返回 `false`。

```python
class Solution:
    def partitionArray(self, nums: List[int], k: int) -> bool:
        n = len(nums)
        if n % k != 0:
            return False
        mx = max(Counter(nums).values())
        return mx * k <= n
```